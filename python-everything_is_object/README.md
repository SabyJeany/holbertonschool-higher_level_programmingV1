This project explores Python's object model, focusing on how Python handles different types of objects, memory management, and the distinction between mutable and immutable types.

Learning Objectives
By the end of this project, you should be able to explain:

Core Concepts
Object: Everything in Python (integers, strings, lists, functions) is an object with a type and value
Class vs Object/Instance: A class is a blueprint/template; an object/instance is a concrete realization of that class
Reference: A name that points to an object in memory
Assignment: Creating a reference to an object (e.g., a = 5)
Alias: Multiple names referring to the same object
Mutability
Immutable Objects: Cannot be modified after creation (int, float, str, tuple, frozenset, bool)
Mutable Objects: Can be modified after creation (list, dict, set, bytearray)
Object Identity & Equality
Identical variables: Use is operator (checks if same memory address)
Equal variables: Use == operator (checks if same value)
Memory address: Use id() function to get object identifier
Type checking: Use type() function
Function Arguments
Python passes variables by assignment (not by value or reference):

Immutable objects appear passed by value
Mutable objects can be modified inside functions
Project Structure
Answer files contain single-line responses to questions about Python's object behavior, focusing on understanding rather than coding.


